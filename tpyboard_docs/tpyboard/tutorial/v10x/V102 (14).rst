[Micropython]TPYBoardV10X教程5 LED-按键手册
=======================================================

	原创版权归山东萝卜科技有限公司所有,转载必须以链接形式注明作者和原始出处。

	1、点亮LED实验
-------------------------------

		通过前面的python入门和有关pyb的介绍，相信你已经很想通过pyb来做一些东西了。那么本篇文章就带大家做一个点亮LED的pyb入门小实验——点亮LED。

		步骤一：

		- 连接pyb开发板（不会的同学请直觉参考http://）

		步骤二：

		- 成功连接pyb开发板后，使用编辑器打开tpyboard里面的main.py文件，输入以下代码::

				import pyb
				Led2=pyb.LED(2)
				led1.on()
				
		import pyb，引用pyb封装的类库，实例化一个LED对象命名为led2，LED对象的唯一参数是1-4之间的数字，分别对应开发板上的D2、D3、D4和D5。然后调用on()函数来点亮LED2。

		Pyb.LED类的函数有：LED.on()亮灯，LED.off()关灯，LED.toggle() 与LED现在的状态对调，LED.intensity([value])设置LED亮度，value是亮度值，0-255，0是关，255最亮（仅LED3和LED4支持）

		步骤三：

		输入代码后保存文件，pyb上的LED1（标有D2标示的LED）亮起大约5秒后熄灭。为了运行我们新写的脚本，需要将pyb进行复位操作，只要按下pyb上标注的RST按键即可。

		注：pyb上标注的D2、D3、D4、D5分别表示LED1，LED2，LED3，LED4

		效果如下：
																
		 *****同学们可尝试使用Pyb.LED类的其他函数，实现流水灯、LED4由亮变暗的小实验*****
	 
	2、按键控制LED实验
---------------------------------

		Pyb上有两个按键，分别是USR和RST，上一篇【点亮LED】的实验中已介绍RST是复位按键，相当于执行对pyb断电后重新上电的操作。本篇将介绍通过USR用户按键控制LED的亮灭实验。

	2.1、按键控制LED亮灭
------------------------------

		步骤一：
		- 连接pyb开发板，使用编辑器打开tpyboard里面的main.py文件，输入以下代码::

			import pyb
			sw=pyb.Switch()
			led=pyb.LED(1)
			led3=pyb.LED(3)
			while True:
				sw_state=sw()
				if sw_state:
					led.on()
					led3.off()
				else:
					led.off()
					led3.on()
					
		实例化一个Switch对象命名为sw，定义两个LED灯，通过LED的亮灭来表示按键的状态（按下或未按下）。sw()函数获取按键当前状态，按下返回True，反之False。当按键按下时，LED1亮起、LED3熄灭。

		步骤二：

		- 按下RST按键，查看运行效果。效果如下：

	2.2、按键回调函数
-------------------------------

		按键回调函数：sw.callback( ) 函数。该函数会在按键按下会执行一些创建的代码，且使用一个中断。我们在main.py输入一下代码::

			import pyb
			sw=pyb.Switch()
			sw.callback(lambda:pyb.LED(1).toggle())
			
		以上例程实现按键每次按下翻转LED1的状态，并且能打断pyb开发板上的任何程序，属于一种异步中断。

		其实，你还可以传递不带参数的函数作为参数给按键回调函数使用，上面的功能我们还可以通过以下形式实现同样的效果::

			import pyb
			sw=pyb.Switch()
			led=pyb.LED(1)
			def test():
				led.toggle()
			sw.callback(test)
			
		如果你不想使用按键回调函数，可以关闭按键回调，只需将函数的参数设置为None即可。

		::

			sw.callback(None)
		
	2.3、中断的原理细节
-------------------------------------------------

		现在谈谈按键回调函数发生时的细节。当你调用了含有 sw.callback( )的函数时，按键将在其连接引脚产生一个边沿触发（下降沿）外部中断。这意味着芯片将监听该引脚的任何状态变换，且如下事情会发生：

		1.当按键被按下时引脚将发生改变（电平由低到高？），芯片处理器将记录这种变化；

		2.处理器完成当前机器指令，退出执行状态并保存当前的状态（将寄存器的内容推入栈中）。这将停止当前运行的任何代码，例如正在执行着的 python 脚本；

		3.芯片开始执行与按键相关的特定外部中断触发处理。该处理指向你在 sw.callback( )函数中指定的函数功能并执行之；

		4.直到回调函数执行完毕，控制主权将回到中断处理手上；

		5.按键中断处理将返回，芯片处理器确认记录该中断被执行过；

		6.芯片调回步骤 2 的状态；

		7.继续执行开始时的代码，除了短暂的暂停，这部分代码看起来似乎没有被打断过。

		当同一时间多个中断同时发生上述的过程将复杂得多。这种情况下拥有最高优先级别的中断将被首先执行，其他的中断按各自的优先级数序执行。按键中断的优先级最低。

	更多资料请参考：http://docs.micropython.org/en/latest/tpyboard/