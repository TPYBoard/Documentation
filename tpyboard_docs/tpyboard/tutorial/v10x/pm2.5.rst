[Micropython]TPYBoardV10X PM2.5检测仪制作
===================================================

	版权声明：翻译整理属于TPYBoard，转载时请以超链接形式标明文章原始出处和作者信息及本声明 


一、[Micropython]TPYBoardV10X PM2.5检测仪制作
----------------------------------------------

	秋冬季节，雾霾天气的持续，让人们对空气质量的关注程度提升。而近期人们对于空气质量的关注总也绕不开一个词--“PM2.5”。《环境空气质量标准》将PM2.5、臭氧(8小时浓度)纳入常规空气质量评价，是我国首次制定关于PM2.5的监测标准。细颗粒物又称细粒、细颗粒、PM2.5.细颗粒物指环境空气中空气动力学当量直径小于等于 2.5 微米的颗粒物。PM2.5粒径小、面积大、活性强、易附带有毒、有害物质(例如,重金属、微生物等)。PM2.5对人体健康有着致命的危害。

那么PM2.5（细颗粒物）是什么？
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	科普:PM2.5到底是神马？

	因为各国标准不一样，天气预报也报空气质量，预报的空气质量与实际的空气质量一样吗？但这个问题，想动手制作一个PM2.5检测仪，有了自己动手制作的PM2.5检测仪的话，当空气质量较差或者严重污染的时候，提醒家人，同学和身边的人尽量减少户外活动，真正减少吸入细颗粒物。

	制作一个PM2.5检测仪的想法是好，在1个小时内能否制作出一个PM2.5检测仪呢？利用C/C++是贴近硬件的语言来做的话，要花好长一段时间甚至半年先学习C语言以后，再考虑动手制作，更不用说1个小时内制作出一个PM2.5检测仪。

	接下来我介绍一个在1个小时内制作一个PM2.5的方法，也就是利用拥有自家的解析器、编译器、虚拟机和类库等，也就是具备二次开发和环境的TPYBoard开发板制作一个PM2.5检测仪吧。

先一起看下最终的视频演示效果吧！



1. PM2.5检测仪的目的
~~~~~~~~~~~~~~~~~~~~~~~~~

	采用TPYBoard开发板为控制处理器，通过串口由PM2.5灰尘传感器GP2Y1010AU0F检测低程度的空气污染PM2.5能够甄别香烟和室内/室外灰尘，并通过SPI接口由LCD5110显示屏显示当前空气粉尘浓度(ug/m?)。当空气中粉尘浓度达到所设定限度点亮不同的LED灯来知道当前空气质量等级。

	本系统电路简单、工作稳定、集成度高，调试方便，测试精度高，具有一定的实用价值。该检测仪通过Python脚本语言实现硬件底层的访问和控制细颗粒物检测传感器，每间隔一定时间，传感器自动进行检测，检测到的空气粉尘浓度数据通过串口上传至主控板，主控板收集到数据后，同样使用Python脚本语言将PM2.5的检测结果显示到LCD5110上。

	``参照1:TPYBoardLED亮灯状态与 PM2.5日均浓度对应的指数等级对应表``
	
+---------------------+--------------------+-----------------+----------------------+
| PM2.5值数           |日均浓度值（ug/m³ ）| 空气质量等级    | LED灯状态            |
+=====================+====================+=================+======================+
| 0～50               | 0-35               | 优              | 绿灯亮               |
+---------------------+--------------------+-----------------+----------------------+
| 50~100              | 35-75              | 良              | 绿灯亮               |
+---------------------+--------------------+-----------------+----------------------+
| 100～150            | 75-115             | 轻度污染        | 蓝灯亮               |
+---------------------+--------------------+-----------------+----------------------+
| 150～200            | 115-150            | 中度污染        | 黄灯亮               |
+---------------------+--------------------+-----------------+----------------------+
| 200～300            | 150-250            | 重度污染        | 红灯亮               |
+---------------------+--------------------+-----------------+----------------------+
| >300                | >250               | 严重污染        | 红灯亮               |
+---------------------+--------------------+-----------------+----------------------+


参照2: TPYBoard的硬件特点：
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	√ STM32F405RG MCU.
	√ 168 MHz Cortex-M4 CPU with 32-bit hardware floating point.
	√ 1 MiB flash storage, 192 KiB RAM.
	√ USB口, 支持 串口，通用存储，HID协议。
	√ SD卡插槽。
	√ MMA76603轴加速度计.
	√ 4 LEDs, 1复位按钮, 1通用按钮.
	√ 3.3V0.3A板载 LDO , 可从USB口或者外置电池供电。
	√ 实时时钟。
	√ 30个通用IO口，其中28个支持5V输入输出。
	√ 2个 SPI接口, 2个 CAN接口, 2个I2C接口, 5个USART接口.
	√ 14个 12-bit ADC引脚。
	√ 2个DAC 引脚。

2. 材料准备
---------------------

制作PM2.5检测仪所需材料如下：
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	1.PM2.5粉尘传感器1个，检测PM2.5（细颗粒物）传感器，TXD串口输出。
	2.TPYBoard开发板1块，主要用来当主控开发板，读入传感器数据。
	3.Lcd5110显示屏1个，主要用来显示检测的信息。
	4.杜邦线若干。
	5.数据线一条。

.. image:: http://www.micropython.net.cn/ueditor/php/upload/image/20160823/1471943991787031.png


3.硬件接线方法
---------------------

3.1 传感器的针脚
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	传感器上一共六根线，从1到6依次是GND,VCC,NC,NC,RX,TX。其中我们只用三根线，电源（GND,VCC）和串口（TX），传感器与TPYBorad接线参照图1，具体用哪个串口请参照官方网站上文档TPYBoard 关于串口的使用，小编用的串口为	UART(2) is on: (TX, RX) = (X3, X4)	= (PA2,	 PA3)，因为只需要将数据传到PTYBoard，所以只用到RED即PTYBoard的X4引脚。

.. image:: http://www.micropython.net.cn/ueditor/php/upload/image/20160823/1471941893958432.png

图1

3.2 LCD5110的针脚
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	先看一下LCD5110针脚含义吧（注意：LCD5110的针脚有些不一样的
	TPYBoard的针脚与5110的针脚对应关系如下：

	+----------+------------+------------------------------------------------+
	| TPYBoard | LCD5110    | memo                                           |
	+==========+============+================================================+
	| Pin      | RST        | Reset pin (0=reset, 1=normal)                  |
	+----------+------------+------------------------------------------------+
	| Pin      | CE         | Chip Enable (0=listen for input,1=ignore input)|
	+----------+------------+------------------------------------------------+
	| Pin      | DC         | Data/Command (0=commands, 1=data)              |
	+----------+------------+------------------------------------------------+
	| MOSI     | DIN        | data flow (Master out, Slave in)               |
	+----------+------------+------------------------------------------------+
	| SCK      | CLK        | SPI clock                                      |
	+----------+------------+------------------------------------------------+
	| 3V3/Pin  | VCC        | 3.3V logic voltage (0=off, 1=on)               |
	+----------+------------+------------------------------------------------+
	| Pin      | LIGHT      | Light (0=on, 1=off)                            |
	+----------+------------+------------------------------------------------+
	| GND      | GND                                                         |
	+----------+------------+------------------------------------------------+

	还是看不明白的话，直接上针脚编号吧

	+----------+------------+------------------------------------------------+
	| TPYBoard | LCD5110    | memo                                           |
	+==========+============+================================================+
	|Y10       | RST        | Reset pin (0=reset, 1=normal)                  |
	+----------+------------+------------------------------------------------+
	|Y11       | CE         | Chip Enable (0=listen for input,1=ignore input)|
	+----------+------------+------------------------------------------------+
	|Y9        | DC         | Data/Command (0=commands, 1=data)              |
	+----------+------------+------------------------------------------------+
	|X8        | DIN        | data flow (Master out, Slave in)               |
	+----------+------------+------------------------------------------------+
	|X6        | CLK        | SPI clock                                      |
	+----------+------------+------------------------------------------------+
	|VCC                                                                     |
	+----------+------------+------------------------------------------------+
	|Y12       | LIGHT      | Light (0=on, 1=off)                            |
	+----------+------------+------------------------------------------------+
	|GND                                                                     |
	+----------+------------+------------------------------------------------+

.. image:: http://www.micropython.net.cn/ueditor/php/upload/image/20160823/1471942009875006.png

图2

3.3 PM2.5检测仪整体接线方法
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	按照图1、图2所示将PM2.5粉尘传感器以及5110显示屏与PTYBoard连接起来，硬件连接完毕，如图3:


.. image:: http://www.micropython.net.cn/ueditor/php/upload/image/20160823/1471942098496980.png

图3

4.PM2.5粉尘传感器工作原理及数据处理
-------------------------------------

4.1 PM2.5粉尘传感器工作原理
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	PM2.5粉尘传感器的工作原理是根据光的散射原理来开发的，微粒和分子在光的照射下会产生光的散射现象，与此同时，还吸收部分照射光的能量。

	当一束平行单色光入射到被测颗粒场时，会受到颗粒周围散射和吸收的影响，光强将被衰减。如此一来便可求得入射光通过待测浓度场的相对衰减率。而相对衰减率的大小基本上能线性反应待测场灰尘的相对浓度。光强的大小和经光电转换的电信号强弱成正比，通过测得电信号就可以求得相对衰减率，进而就可以测定待测场里灰尘的浓度。在传感器的中间有一个洞，这个洞可以让空气在里面流通。在洞的两个边缘 ，一面安装有一个激光发射器，另一面安装有激光接收器。这样一来，空气流过这个小洞，空气里的颗粒物呢就会挡住激光，从而产生散射，另一面的接收器，是依据接收到的激光强度来发出不同的信号的（其实就是输出不同的电压值）。这样一来，空气里的颗粒物越多，输出的电压越高，颗粒物越少，输出的电压越低。

	内部结构如图内部结构仿真图所示：

.. image:: http://www.micropython.net.cn/ueditor/php/upload/image/20160823/1471942150331605.png

内部结构仿真图

4.2 PM2.5粉尘传感器传感器数据处理
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	上面说了传感器的原理，接下来就说说它传出来的信号和对于接收到的信号的计算吧。

	这个传感器的输出数据是靠串口进行传输的，传感器会通过串口每10ms不到（一般3～4ms）发送一个数据，数据的类型大致是个“0X00”这样的16进制的数据。每次的数据会以“0XAA”作为起始端，以“0XFF”作为结束端。共7个数据位，7个数据位中包含了起始位，结束位，数据高位，数据低位，数据高校验位，数据低校验位和校验位（校验位是怎样计算出来的，下面会讲到）。数据格式大致如下：

.. image:: http://www.micropython.net.cn/ueditor/php/upload/image/20160823/1471942195856275.png

其中校验位长度=Vout（H）+Vout（L）+Vref（H）+Vref（L）的长度。

	数据的组成一共是有7个数据位，但是只有Vout（H）和Vout（L）这两个数据才是我们真正所需要的。我们需要依照这两个数据算出来串口输出的数字数据，从而通过数模转换公式来计算出输出的电压。进一步的通过比例系数计算出空气中颗粒物的数量。下面来说一下怎么计算。

	传感器输出的数据分为高位和低位，其中呢Vout（H）为高位，Vout（L）为低位。因为串口传进来的Vout（H）和Vout（L）是16进制的，第一步先转化成10进制的（这个大家都会，不多说了）。然后根据这两个输出值的10进制数计算出串口输出数值的电压。

	公式如下（其中Vout（H）和Vout（L）是已转化为10进制的）：

	Vout=（Vout（H）*256+Vout（L））/1024*5

	这样就算出来了他输出出来的电压了，再根据比例系数A，就可以计算出空气中的颗粒物的值了。（A的值一般是在800到1000，具体的数值还要根据你买到的传感器的精度，准确度和误差值进行确定。我现在用的是800。）

5.PM2.5粉尘传感器的采样频率及程序编码
----------------------------------------

5.1PM2.5粉尘传感器的采样频率
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	PM2.5粉尘传感器的采样频率是非常高的，一般3～4ms发送一个16进制的采样数据，也就是说传感器通电（接通VCC和GND）后，每隔3～4ms发送一个16进制的采样数据，这么高的采样频率作为一个检测仪来说显然是没有必要的。

	TPYBoard通过串口接收粉尘传感器数据，使用串口当然先定义串口，通过打开就可以接收串口数据，关闭串口就停止接收数据的特点，来自由控制PM2.5粉尘传感器的采样频率。

5.2程序编码
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	我们main.py中，采用首先定义串口，其次是打开串口接收采样数据，最后关闭串口，并且处理采样数据及显示，依次循环。

6.运行测试
-----------------

	接线ok后，导入font.py文件和upcd8544.py文件(主要用于5110显示数据），再运行main.py即可看到当前的空气质量等级以及PM2.5的浓度值了。

7.源代码
------------------------

	把我写的程序的源码分享给大家，有需要的可以参考一下。

.. code-block:: python

	# main.py -- put your code here!
	#main.py
	import pyb
	import upcd8544
	from machine import SPI,Pin
	from pyb import UART
	from ubinascii import hexlify
	from ubinascii import *
	 
	 
	leds = [pyb.LED(i) for i in range(1,5)] 
	P,L,SHUCHU=0,0,0
	#A比例系数，在北方一般使用800-1000.南方空气好一些，一般使用600-800.这个还和你使用的传感器灵敏度有关的，需要自己测试再定下来
	A=800
	#G为固定系数，是为了把串口收到的数据转换成PM标准值
	G=1024/5
	SPI = pyb.SPI(1) #DIN=>X8-MOSI/CLK=>X6-SCK
	#DIN =>SPI(1).MOSI 'X8' data flow (Master out, Slave in)
	#CLK =>SPI(1).SCK  'X6' SPI clock
	RST	   = pyb.Pin('Y10')
	CE	   = pyb.Pin('Y11')
	DC	   = pyb.Pin('Y9')
	LIGHT  = pyb.Pin('Y12')
	lcd_5110 = upcd8544.PCD8544(SPI, RST, CE, DC, LIGHT)
	u2 = UART(2, 2400)
	count_=0
	def ChangeLEDState(num_):
		global leds
		len_=len(leds)
		for i in range(0,len_):
			if i!=num_:
				leds[i].off()
			else:
				leds[i].on()
	while True:
		u2.init(2400, bits=8, parity=None, stop=1)
		pyb.delay(80)
		Quality='DATA NULL'
		if(u2.any()>0):
			u2.deinit()
			_dataRead=u2.readall()
			#R代表截取数据的起始位
			R=_dataRead.find(b'\xaa')
			#R>-1代表存在起始位，长度大于起始位位置+2
			if R>-1 and len(_dataRead)>(R+2):
				P=_dataRead[R+1]
				L=_dataRead[R+2]
				#把串口收到的十六进制数据转换成十进制
				SHI=P*256+L	 
				SHUCHU=SHI/G*A
			if(SHUCHU<35):
				Quality = 'Excellente'
				print('环境质量:优','PM2.5=',SHUCHU)
				count_=1
			elif(35<SHUCHU<75):
				Quality = 'Good'
				print('环境质量：良好','PM2.5=',SHUCHU)
				count_=1
			elif(75<SHUCHU<115):
				Quality = 'Slightly-polluted'
				print('环境质量：轻度污染 ','PM2.5=',SHUCHU)
				count_=3
			elif(115<SHUCHU<150):
				Quality = 'Medium pollution'
				print('环境质量：中度污染 ','PM2.5=',SHUCHU)
				count_=2
			elif(150<SHUCHU<250):
				Quality = 'Heavy pollution'
				print('环境质量：重度污染 ','PM2.5=',SHUCHU)
				count_=0
			elif(250<SHUCHU):
				Quality = 'Serious pollution'
				print('环境质量：严重污染 ','PM2.5=',SHUCHU)
				count_=0
		ChangeLEDState(count_)
		lcd_5110.lcd_write_string('AQI Level',0,0)
		lcd_5110.lcd_write_string(str(Quality),0,1)
		lcd_5110.lcd_write_string('PM2.5:',0,2)
		lcd_5110.lcd_write_string(str(SHUCHU),0,3)
