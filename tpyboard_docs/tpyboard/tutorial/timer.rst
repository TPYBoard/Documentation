定时器
==========

该板具有14个定时器，每个定时器由用户定义的频率运行的独立计数器组成。
它们可以设置为以特定间隔运行功能。
14个定时器编号为1到14，但3个保留供内部使用，5和6用于伺服和ADC / DAC控制。
如果可以，避免使用这些计时器。

让我们创建一个定时器对象：

    >>> tim = pyb.Timer(4)

现在我们来看看刚刚创建的内容：

    >>> tim
    Timer(4)

这个TPYboard告诉我们tim是附加到定时器4，但它还没有初始化。
所以让我们初始化它以10Hz（即每秒10次）触发：

    >>> tim.init(freq=10)

现在，它已初始化，我们可以看到有关定时器的一些信息：

    >>> tim
    Timer(4, prescaler=624, period=13439, mode=UP, div=1)

该信息意味着该计时器设置为在外设运行时钟速度除以624 + 1，
它将从0到13439计数，此时触发中断，然后再次从0开始计数。
设置使定时器触发为10 Hz：定时器的源频率为84MHz（由运行发现tim.source_freq()），
所以我们得到84MHz / 625/13440 = 10Hz。

定时器计数器
-------------

那么我们可以用定时器做什么呢？最基本的是获取其计数器的当前值：

    >>> tim.counter()
    21504

此计数器将不断变化，并计数。

定时器回调
---------------

接下来我们可以注册一个回调函数，使定时器在触发时执行（参见[switch tutorial]（tut-switch）来介绍回调函数）：

    >>> tim.callback(lambda t:pyb.LED(1).toggle())

这应该立即开始红色LED闪烁。
它将以5 Hz闪烁（1闪光灯需要2个切换，因此10 Hz的切换使其以5 Hz闪烁）。
您可以通过重新初始化定时器来更改频率：

    >>> tim.init(freq=20)

您可以通过传递值来禁用回调：

    >>> tim.callback(None)

传递给回调的函数必须采用1个参数，即触发的定时器对象。这允许您从回调函数内控制定时器。

我们可以创建2个计时器并独立运行：

    >>> tim4 = pyb.Timer(4, freq=10)
    >>> tim7 = pyb.Timer(7, freq=20)
    >>> tim4.callback(lambda t: pyb.LED(1).toggle())
    >>> tim7.callback(lambda t: pyb.LED(2).toggle())

因为回调是正确的硬件中断，所以我们可以在这些计时器运行时继续使用TPYboard来进行其他的操作。

制造一个微秒计数器
----------------------------

您可以使用计时器创建一个微秒计数器，当您正在进行需要准确计时的操作时，它可能会很有用。
我们将使用定时器2，因为定时器2有一个32位计数器（定时​​器5也是这样，但如果使用定时器5，则不能同时使用继动驱动器）。

我们设置定时器2如下：

    >>> micros = pyb.Timer(2, prescaler=83, period=0x3fffffff)

预分频器设置为83，使定时器计数为1 MHz。
这是因为运行在168 MHz的CPU时钟除以2，然后由预分频器+ 1分频，为定时器2提供168 MHz / 2 /（83 + 1）= 1 MHz的频率。
该周期设置为大数量，使定时器可以计数到大量之前回绕到零。
在这种情况下，大约需要17分钟才能循环回零。

要使用此定时器，最好首先将其重置为0：

    >>> micros.counter(0)

然后执行你的计时：  

    >>> start_micros = micros.counter()

    ... do some stuff ...

    >>> end_micros = micros.counter()
